import os
import hmac
import time
import hashlib, logging
from functools import wraps
from django.http import JsonResponse
from django.utils.deprecation import MiddlewareMixin

logger = logging.getLogger(__name__)

API_KEY = os.getenv("INTEGRATION_API_KEY", "")
HMAC_SECRET = os.getenv("INTEGRATION_HMAC_SECRET", "")
MAX_SKEW = int(os.getenv("HMAC_MAX_SKEW_SECONDS", "300"))

def _client_ip(request):
    xff = request.META.get("HTTP_X_FORWARDED_FOR")
    if xff:
        return xff.split(",")[0].strip()
    xri = request.META.get("HTTP_X_REAL_IP")
    if xri:
        return xri.strip()
    return request.META.get("REMOTE_ADDR", "")

def _bad(code, detail):
    return JsonResponse({"detail": detail}, status=code)

def _ip_allowed(request):
    try:
        allow = (os.getenv("ONEC_ALLOW_IPS") or "").split(",")
        allow = [a.strip() for a in allow if a.strip()]
        if not allow:
            return True
        real_ip = (request.META.get("HTTP_X_REAL_IP")
                   or request.META.get("REMOTE_ADDR") or "")
        return any(real_ip == a or real_ip.startswith(a.rstrip("*")) for a in allow)
    except Exception as e:
        logger.exception("ip check failed: %s", e)
        return False


def require_onec_auth(view_func):
    """
    Проверяет:
      - IP по белому списку (если задан)
      - заголовки X-Api-Key, X-Timestamp, X-Sign
      - окно времени +/- MAX_SKEW
      - HMAC-SHA256 по строке: f"{timestamp}." + raw_body
      - сравнение в байтах; X-Sign допускает hex или base64/base64url
    """
    from functools import wraps
    import time, hmac, hashlib, binascii, re
    def _bad(code, detail):
        from django.http import JsonResponse
        return JsonResponse({"detail": detail}, status=code)

    HEX64_RE = re.compile(r"^[0-9a-fA-F]{64}$")

    @wraps(view_func)
    def _wrapped(request, *args, **kwargs):
        try:
            from .security import API_KEY, HMAC_SECRET, MAX_SKEW, _ip_allowed  # reuse существующих настроек
            if not API_KEY or not HMAC_SECRET:
                return _bad(401, "Server auth not configured")
            if not _ip_allowed(request):
                return _bad(403, "IP not allowed")

            api_key = request.META.get("HTTP_X_API_KEY")
            ts      = request.META.get("HTTP_X_TIMESTAMP")
            sign_in = (request.META.get("HTTP_X_SIGN") or "").strip()

            if not api_key or not ts or not sign_in:
                return _bad(401, "Missing auth headers")
            if api_key != API_KEY:
                return _bad(401, "Bad API key")

            try:
                ts_int = int(str(ts))
            except Exception:
                return _bad(401, "Bad timestamp")

            if abs(int(time.time()) - ts_int) > MAX_SKEW:
                return _bad(401, "Stale timestamp")

            body = request.body or b""
            msg  = f"{ts}.".encode("utf-8") + body
            raw_digest = hmac.new(HMAC_SECRET.encode("utf-8"), msg, hashlib.sha256).digest()
            expected_hex = binascii.hexlify(raw_digest)  # bytes lower-hex

            # Нормализация подписи: HEX или Base64/Base64URL
            if HEX64_RE.match(sign_in):
                ok = hmac.compare_digest(expected_hex, sign_in.lower().encode("ascii", "strict"))
            else:
                s_b64 = sign_in.replace("-", "+").replace("_", "/")
                pad   = "=" * ((4 - len(s_b64) % 4) % 4)
                try:
                    sign_raw = binascii.a2b_base64(s_b64 + pad)
                except binascii.Error:
                    return _bad(401, "Bad signature encoding")
                ok = hmac.compare_digest(raw_digest, sign_raw)

            if not ok:
                return _bad(401, "Bad signature")

            return view_func(request, *args, **kwargs)
        except Exception as e:
            import logging
            logging.getLogger(__name__).exception("require_onec_auth crashed: %s", e)
            return _bad(401, "Bad signature")
    return _wrapped

